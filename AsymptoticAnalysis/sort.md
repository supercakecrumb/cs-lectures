# Простые алгоритмы сортировки

## Сортировка выбором (Selection Sort)

### Идея алгоритма
Алгоритм находит минимальный элемент в неотсортированной части массива и меняет его местами с первым элементом неотсортированной части. Процесс повторяется для оставшихся элементов.

### Реализация на Go
```go
func selectionSort(arr []int) {
    n := len(arr)
    for i := 0; i < n-1; i++ {
        minIndex := i
        for j := i + 1; j < n; j++ {
            if arr[j] < arr[minIndex] {
                minIndex = j
            }
        }
        arr[i], arr[minIndex] = arr[minIndex], arr[i]
    }
}
```

### Анализ сложности
- **Временная сложность:**
  - Лучший случай: O(n²)
  - Худший случай: O(n²)
  - Средний случай: O(n²)
- **Пространственная сложность:** O(1) — сортировка на месте
- **Стабильность:** Нестабильный алгоритм

### Ключевые свойства
- Всегда выполняет одинаковое количество сравнений
- Минимальное количество обменов среди простых алгоритмов сортировки
- Производительность не зависит от исходного порядка элементов

## Сортировка вставками (Insertion Sort)

### Идея алгоритма
Алгоритм строит отсортированную последовательность по одному элементу за раз. Каждый новый элемент вставляется в правильную позицию среди уже отсортированных элементов.

### Реализация на Go
```go
func insertionSort(arr []int) {
    n := len(arr)
    for i := 1; i < n; i++ {
        key := arr[i]
        j := i - 1
        
        // Сдвигаем элементы, которые больше key
        for j >= 0 && arr[j] > key {
            arr[j+1] = arr[j]
            j--
        }
        arr[j+1] = key
    }
}
```

### Анализ сложности
- **Временная сложность:**
  - Лучший случай: O(n) — массив уже отсортирован
  - Худший случай: O(n²) — массив отсортирован в обратном порядке
  - Средний случай: O(n²)
- **Пространственная сложность:** O(1) — сортировка на месте
- **Стабильность:** Стабильный алгоритм

### Ключевые свойства
- Эффективен для небольших массивов
- Адаптивный — работает быстрее на частично отсортированных данных
- Онлайн-алгоритм — может сортировать данные по мере их поступления

## Пузырьковая сортировка (Bubble Sort)

### Идея алгоритма
Алгоритм многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они стоят в неправильном порядке. Процесс повторяется до тех пор, пока не будет сделан проход без обменов.

### Реализация на Go
```go
func bubbleSort(arr []int) {
    n := len(arr)
    for i := 0; i < n-1; i++ {
        swapped := false
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = true
            }
        }
        // Если обменов не было, массив отсортирован
        if !swapped {
            break
        }
    }
}
```

### Анализ сложности
- **Временная сложность:**
  - Лучший случай: O(n) — массив уже отсортирован (с оптимизацией)
  - Худший случай: O(n²) — массив отсортирован в обратном порядке
  - Средний случай: O(n²)
- **Пространственная сложность:** O(1) — сортировка на месте
- **Стабильность:** Стабильный алгоритм

### Ключевые свойства
- Простейший для понимания алгоритм сортировки
- Может быть оптимизирован для раннего завершения
- Наименее эффективный среди рассматриваемых алгоритмов

## Сравнительная таблица

| Алгоритм | Лучший случай | Худший случай | Средний случай | Память | Стабильность |
|----------|---------------|---------------|----------------|---------|--------------|
| Selection Sort | O(n²) | O(n²) | O(n²) | O(1) | Нестабильный |
| Insertion Sort | O(n) | O(n²) | O(n²) | O(1) | Стабильный |
| Bubble Sort | O(n) | O(n²) | O(n²) | O(1) | Стабильный |

### Выводы
- Все три алгоритма имеют квадратичную сложность в худшем случае
- Insertion Sort и Bubble Sort адаптивны — эффективнее работают на частично отсортированных данных
- Selection Sort выполняет минимальное количество обменов
- Для практического применения на больших данных рекомендуется использовать более эффективные алгоритмы (Quick Sort, Merge Sort, Heap Sort)