# Куча — Практические основы (с простыми примерами на C)

**Цель**: понять, что такое куча, когда её использовать, и несколько правил, которые помогут избежать проблем. C используется только как микроскоп — концепции применимы к любому языку с динамической памятью.

---

## Что такое куча (и чем она не является)

* **Куча**: общий для процесса пул для **динамической** памяти. Вы запрашиваете байты во время выполнения и освобождаете их, когда они больше не нужны.
* **Зачем использовать**: данные переменного размера, данные, которые должны пережить функцию, или данные, разделяемые между функциями/потоками.
* **Не стек**: стек существует для каждого вызова и кратковременен; переменные исчезают при возврате.
* **Не статические/глобальные**: они существуют всё время работы программы и создаются при запуске.

---

## Несколько основных правил (запомните их)

1. **Вы владеете тем, что выделили**: один чёткий владелец, один вызов `free`.
2. **Не трогайте после освобождения**: установите указатели в `NULL` после освобождения.
3. **Не выходите за границы**: выделяйте достаточно места (строкам нужно `+1` для `�`).
4. **Указатели могут перемещаться**: `realloc` может вернуть **другой** адрес — используйте возвращаемое значение.

---

## Демо 1 · Адрес в куче стабилен между вызовами; в стеке — нет

```c
// heap_stability.c
#include <stdio.h>
#include <stdlib.h>

static int *g; // указывает на память в куче

static void show(const char *who) {b z 
    int stack_local = 0; // в этом фрейме
    printf("%s: &stack_local=%p  g=%p -> %d
", who, (void*)&stack_local, (void*)g, *g);
}

static void f1(void) { show("f1"); }
static void f2(void) { show("f2"); }

int main(void) {
    g = malloc(sizeof *g); *g = 1234;
    show("main"); f1(); f2();
    free(g); g = NULL;
}
```

* Адрес в стеке меняется для каждой функции; указатель в куче остаётся тем же, пока существует.

---

## Демо 2 · Строки и массивы в куче (просто и безопасно)

```c
// heap_data.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
    // Строка в куче
    const char *src = "dynamic";
    size_t n = strlen(src) + 1;     // +1 для терминатора
    char *s = malloc(n);
    memcpy(s, src, n);

    // Массив в куче
    size_t len = 5;
    int *a = malloc(len * sizeof *a);
    for (size_t i = 0; i < len; ++i) a[i] = (int)(10*i);

    printf("s='%s' at %p
", s, (void*)s);
    printf("a at %p: ", (void*)a);
    for (size_t i = 0; i < len; ++i) printf("%d ", a[i]); puts("");

    free(a); free(s);
}
```

* Строковые литералы доступны только для чтения; строки в куче можно изменять и их нужно освобождать.

---

## Демо 3 · Что может пойти не так (сборка с санитайзерами)

```c
// heap_mistakes.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
    char *p = malloc(8);
    strcpy(p, "this is too long"); // ❌ переполнение (запись за пределы 8 байт)

    int *q = malloc(sizeof *q);
    free(q);
    // printf("%d
", *q);        // ❌ использование после освобождения (закомментировано для безопасного запуска)

    // free(q);                    // ❌ двойное освобождение (не делайте этого)

    free(p);
}
```

**Компиляция с проверками** (Clang/GCC):

```bash
gcc -O0 -g -fsanitize=address,undefined -fno-omit-frame-pointer heap_mistakes.c -o heap_mistakes
./heap_mistakes
```

Санитайзер точно укажет на проблемную строку (переполнение / использование после освобождения / двойное освобождение), чтобы вы могли её исправить.

---

## Дополнительный пример (не в английской версии)

### Демо 4 · `realloc` может переместить блок

```c
// heap_realloc.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
    char *p = malloc(8);
    strcpy(p, "hi");
    printf("p=%p '%s'
", (void*)p, p);

    char *tmp = realloc(p, 4096); // может переместить
    if (!tmp) { free(p); return 1; }
    p = tmp;

    printf("p(now)=%p '%s'
", (void*)p, p);
    free(p);
}
```

**Шаблон**: `tmp = realloc(p, new_size); if (tmp) p = tmp; else { /* p остаётся неизменным */ }`.

---

## Паттерны владения (языко-независимая идея)

* **Фабрика возвращает владение**: функция создаёт объект, и вызывающий освобождает его.
* **Буфер, принадлежащий вызывающему**: вызывающий предоставляет память; вызываемая функция заполняет её (без выделения).
* **Выходной параметр**: вызываемая функция выделяет память и записывает указатель обратно (вызывающий освобождает).

Минимальный набросок выходного параметра на C:

```c
int make_array(int **out, size_t n) {
    *out = malloc(n * sizeof **out);
    return *out ? 0 : -1;
}
```

---

## Краткий чеклист

* Действительно ли мне нужна динамическая продолжительность жизни/размер? Если нет, предпочитайте стек.
* Выделил ли я достаточно байт (включая терминаторы/заполнение)?
* Кому принадлежит этот указатель, и где находится единственный `free`?
* После `realloc` переключился ли я на возвращённый указатель?
* После `free` обнулил ли я все псевдонимы?