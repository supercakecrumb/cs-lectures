# Лекция: Динамическая память (куча)

В C память делится на несколько сегментов: стек, сегмент данных, сегмент кода и **куча** (heap). В отличие от стека, где память выделяется/освобождается автоматически при входе/выходе из функций, куча — это область памяти для ручного управления.

Программист запрашивает нужный объём байт, использует его и обязан освободить, когда память больше не нужна. Это даёт гибкость: можно создавать структуры данных, размер которых неизвестен на этапе компиляции.

Основные функции для работы с кучей:
- `malloc(size_t size)`: выделяет `size` байт и возвращает указатель на начало блока или `NULL`.
- `free(void *ptr)`: освобождает ранее выделенный блок (`ptr` должен быть из `malloc`/`calloc`/`realloc`).
- `calloc(size_t num, size_t size)`: как `malloc`, но память обнулена.
- `realloc(void *ptr, size_t new_size)`: меняет размер блока, возможно перемещая его.

Условности для таблиц ниже:
- Адреса условные и иллюстративные. Для стека берём 0x1000 и ниже (стек убывает), для кучи — 0x2000 и выше (растёт вверх).
- Порядок байт — little endian.
- Для наглядности считаем 64‑битную платформу: указатели занимают 8 байт.

---

### Пример 1. Один `int` в куче

Выделим память для одного целого числа, запишем туда значение и освободим.

**Код:**
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *p; // указатель на int — лежит на стеке
    printf("sizeof(int) = %zu, sizeof(int*) = %zu\n", sizeof(int), sizeof(int*));

    p = malloc(sizeof(int)); // выделяем 4 байта в куче
    printf("p (адрес в куче) = %p, &p (адрес указателя на стеке) = %p\n", p, &p);

    *p = 123;
    printf("*p = %d\n", *p);

    free(p);
    printf("free(p) выполнен\n");

    return 0;
}
```

**Срезы памяти в разные моменты исполнения:**

**1. После `int *p;`**
Указатель `p` создан на стеке, но пока не инициализирован (содержит мусор).

*Стек*
| Адрес   | Значение (байты)                      | Комментарий                 |
|---------|---------------------------------------|-----------------------------|
| 0x1000  | `?? ?? ?? ?? ?? ?? ?? ??`             | `int *p` (8 байт, мусор)    |

**2. После `p = malloc(sizeof(int));`**
`malloc` выделил 4 байта в куче (например, по адресу `0x2000`) и вернул этот адрес. Адрес был записан в `p`.

*Стек*
| Адрес   | Значение (байты)                      | Комментарий                                 |
|---------|---------------------------------------|---------------------------------------------|
| 0x1000  | `00 20 00 00 00 00 00 00`             | `p` (указатель на 0x2000, 8 байт, LE)        |

*Куча*
| Адрес   | Значение (байты) | Комментарий                          |
|---------|-------------------|--------------------------------------|
| 0x2000  | `?? ?? ?? ??`     | 4 байта под `int`, пока мусор        |

**3. После `*p = 123;`**
Число 123 (в hex `0x7B`) записано в кучу по адресу, который хранится в `p`. Используется порядок байт little-endian.

*Стек*
| Адрес   | Значение (байты)                      | Комментарий                                 |
|---------|---------------------------------------|---------------------------------------------|
| 0x1000  | `00 20 00 00 00 00 00 00`             | `p` (указатель на 0x2000)                   |

*Куча*
| Адрес   | Значение (байты) | Комментарий                |
|---------|-------------------|----------------------------|
| 0x2000  | `7B 00 00 00`     | `*p = 123` (int, 4 байта)  |

**4. После `free(p);`**
Память в куче по адресу `0x2000` помечена как свободная. Она может быть переиспользована для следующих вызовов `malloc`. Указатель `p` на стеке всё ещё хранит старый адрес!

*Стек*
| Адрес   | Значение (байты)                      | Комментарий                        |
|---------|---------------------------------------|------------------------------------|
| 0x1000  | `00 20 00 00 00 00 00 00`             | `p`, висячий указатель (dangling)  |

*Куча*
| Адрес   | Значение (байты) | Комментарий                                 |
|---------|-------------------|---------------------------------------------|
| 0x2000  | `?? ?? ?? ??`     | Блок свободен; содержимое не определено     |

**Пояснение:**
Мы создали указатель `p` на стеке. С помощью `malloc` мы запросили 4 байта в куче. Адрес этого блока памяти был сохранён в `p`. Затем мы записали число `123` в кучу, используя `*p`. После использования мы освободили память с помощью `free(p)`.

Принципы:
- sizeof сообщает реальный размер типа/указателя на вашей платформе.
- На 64‑битных системах `sizeof(int*)` обычно 8.
- Указатель хранит адрес (число). В little endian его младшие байты стоят по меньшим адресам.

---

### Пример 2. Массив из 5 `int`

Выделим память для массива, заполним его и выведем значения.

**Код:**
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    printf("sizeof(int) = %zu, sizeof(int*) = %zu\n", sizeof(int), sizeof(int*));
    int *arr = malloc(5 * sizeof(int));
    if (arr == NULL) {
        return 1; // Проверка, что память выделилась
    }

    for (int i = 0; i < 5; i++) {
        arr[i] = i + 1;
    }

    for (int i = 0; i < 5; i++) {
        printf("arr[%d] = %d, &arr[%d] = %p\n", i, arr[i], i, &arr[i]);
    }

    printf("arr (указатель) = %p, &arr (на стеке) = %p\n", arr, &arr);
    free(arr);
    return 0;
}
```

**Срез памяти после заполнения массива:**

*Стек*
| Адрес   | Значение (байты)                      | Комментарий                         |
|---------|---------------------------------------|-------------------------------------|
| 0x1000  | `00 20 00 00 00 00 00 00`             | `int *arr = 0x2000` (8 байт, LE)    |

*Куча*
| Адрес   | Значение (байты) | Комментарий      |
|---------|-------------------|------------------|
| 0x2000  | `01 00 00 00`     | `arr[0] = 1`     |
| 0x2004  | `02 00 00 00`     | `arr[1] = 2`     |
| 0x2008  | `03 00 00 00`     | `arr[2] = 3`     |
| 0x200C  | `04 00 00 00`     | `arr[3] = 4`     |
| 0x2010  | `05 00 00 00`     | `arr[4] = 5`     |

**Пояснение:**
Мы выделили `5 * 4 = 20` байт в куче. `malloc` вернул указатель на начало этого блока, который мы сохранили в `arr`. Память в куче для массива является непрерывной, поэтому элементы `arr[0]`, `arr[1]` и т.д. лежат друг за другом.

Советы:
- Всегда проверяйте `arr != NULL`.
- Храните длину массива рядом с указателем; куча «не знает» размер.

---

### Пример 3. Строка в куче (`char[]` + нулевой байт)

Строки в C — это массивы символов, заканчивающиеся нулевым символом `\0`.

**Код:**
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char *s = malloc(6); 
    if (s == NULL) return 1;

    strcpy(s, "Hello");
    printf("Строка: %s, s = %p, &s = %p, sizeof(char) = %zu\n", s, s, &s, sizeof(char));

    free(s);
    return 0;
}
```

**Срез памяти после `strcpy`:**

*Стек*
| Адрес   | Значение (байты)                      | Комментарий                      |
|---------|---------------------------------------|----------------------------------|
| 0x1000  | `00 20 00 00 00 00 00 00`             | `char *s = 0x2000`               |

*Куча*
| Адрес   | Значение (байт) | Комментарий     |
|---------|------------------|-----------------|
| 0x2000  | `0x48`           | `s[0] = 'H'`    |
| 0x2001  | `0x65`           | `s[1] = 'e'`    |
| 0x2002  | `0x6C`           | `s[2] = 'l'`    |
| 0x2003  | `0x6C`           | `s[3] = 'l'`    |
| 0x2004  | `0x6F`           | `s[4] = 'o'`    |
| 0x2005  | `0x00`           | `s[5] = '\0'`  |

**Пояснение:**
Мы выделили 6 байт в куче. `strcpy` скопировала символы строки "Hello" и завершающий `\0` в выделенную память. Функции для работы со строками, такие как `printf("%s", ...)` или `strlen`, ориентируются на этот нулевой символ для определения конца строки.

---

### Пример 4. Утечка памяти (Memory Leak)

Что будет, если постоянно выделять память и не освобождать её?

**Код:**
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    long long i = 0;
    while (1) {
        // Выделяем 1 МБ
        void *p = malloc(1000000); 
        if (p == NULL) {
            printf("Не удалось выделить память на итерации %lld\n", i);
            break;
        }
        printf("Итерация %lld: выделен 1 МБ\n", i);
        i++;
        // free(p) отсутствует!
    }
    return 0;
}
```

**Пояснение:**
Эта программа находится в бесконечном цикле, на каждой итерации которого выделяется 1 МБ памяти в куче. Поскольку мы никогда не вызываем `free()`, выделенная память не возвращается системе. Это называется **утечкой памяти**.

Рано или поздно свободная память в куче закончится. В этот момент `malloc` не сможет выделить очередной блок и вернёт `NULL`. Наша программа обнаружит это и завершит цикл. В реальных приложениях утечки памяти приводят к тому, что программа начинает потреблять всё больше и больше оперативной памяти, замедляя систему и в итоге аварийно завершаясь.

---

### Пример 5. Использование после освобождения (Use-After-Free)

Что произойдёт, если мы попытаемся использовать память после вызова `free()`?

**Код:**
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *p = malloc(sizeof(int));
    *p = 42;
    printf("До free: *p = %d\n", *p);

    free(p);
    
    printf("После free: *p = %d\n", *p);
    
    *p = 99;
    printf("После новой записи: *p = %d\n", *p);

    return 0;
}
```

**Пояснение:**
Вызов `free(p)` не изменяет значение самого указателя `p` — он всё ещё хранит адрес `0x2000`. `free` лишь сообщает менеджеру памяти, что блок по этому адресу теперь свободен.

Попытка чтения или записи по этому адресу (`*p`) приводит к **неопределённому поведению (Undefined Behavior)**. Это значит, что может произойти что угодно:
1.  **Программа может аварийно завершиться (Segmentation Fault), если эта область памяти была возвращена операционной системе.**
2.  Программа может прочитать "мусор", если менеджер памяти записал в этот блок служебную информацию.
3.  Программа может успешно прочитать старое значение (42), потому что память ещё не была переписана.
4.  Самое коварное: запись в эту область может "молча" повредить данные, которые были выделены для других частей программы, что приведёт к трудноуловимым ошибкам.

Указатель, который указывает на освобождённую память, называется **висячим указателем (dangling pointer)**.


---

## Эксперименты для димзима

1. **Адреса в куче:** Меняются ли адреса при повторном malloc (malloc(p)->free(p)->malloc(p))? Напишите программу, чтобы это выяснить. Почему так происходит?
2.  **Переполнение буфера:** Выделите для строки "Hello" меньше памяти, чем нужно, например, malloc(4). Что произойдёт при вызове strcpy?
3.  **Исчерпание кучи:** Сколько программа в вашей системе может взять байт из хипа. Проверьте это и выведите примерное число.
4. **На затравочку**: Напишите программу, которая расшифрует строку, состоящую из байтов 62 61 64 7A 69 6D 00.

### Шпора


#### Compilation
```bash
gcc file.c -o app
./app
```

#### Program Template
```c
#include <stdio.h>    // printf
#include <stdlib.h>   // malloc, realloc, free
#include <string.h>   // strcpy, strlen

int main(void) {
    return 0;
}
```

#### <stdio.h> Functions

| Function        | Description          | Example |
|-----------------|----------------------|---------|
| `printf(fmt, ...)` | Formatted output | `printf("Value: %d", 42);` |

### printf Format Specifiers

| Format | Output               | Example |
|--------|----------------------|---------|
| `%p`   | Pointer (address)    | `printf("%p", &var);` |
| `%d`   | int (decimal)        | `printf("%d", num);` |
| `%zu`  | size_t (size)        | `printf("%zu", sizeof(int));` |
| `%s`   | String (char*)       | `printf("%s", "hello");` |
| `%c`   | Character (char)     | `printf("%c", 'A');` |
| `%x`   | Hexadecimal (int)    | `printf("%x", 255);` |
| `%02x` | Byte in hex (with leading zero) | `printf("%02x", 15);` |

### <stdlib.h> Functions

| Function        | Description          | Example |
|-----------------|----------------------|---------|
| `malloc(n)`     | Allocate n bytes     | `int *p = malloc(10 * sizeof(int));` |
| `realloc(p, n)` | Resize block p to n bytes | `p = realloc(p, 20 * sizeof(int));` |
| `free(p)`       | Free memory          | `free(p);` |

### <string.h> Functions

| Function        | Description          | Example |
|-----------------|----------------------|---------|
| `strlen(s)`     | String length (without null terminator) | `int len = strlen("hello");` |
| `strcpy(dst, src)` | Copy string       | `strcpy(dest, "hello");` |