## Часть 0 · Биты и байты (основы)

**Основные факты**

* **Бит** (bit) - это 0 или 1.  
* **Байт** (byte) - это 8 бит и является **наименьшей адресуемой единицей** в современных процессорах (x86/x86-64, ARM/ARM64). Каждый адрес памяти указывает на один **байт**.  
* **Слово** (word) - это естественный размер регистра процессора (часто 32 или 64 бита). Это **не** наименьшая адресуемая единица.  
* Адреса считают байты; **типы данных** определяют, сколько байт нужно прочитать/записать, начиная с этого адреса.  

* На практике в x86/x86-64 и ARM/ARM64 используется **порядок little-endian**. В сетевых протоколах используется **big-endian** ("сетевой порядок байтов").  

---

### Выравнивание (основы)

* Компиляторы предпочитают хранить 4-байтовые `int` по адресам, кратным 4, а 8-байтовые `long`/`double` - по адресам, кратным 8.  
* **x86** допускает невыровненный доступ (медленнее). Некоторые архитектуры могут вызывать ошибки или требовать специальной обработки.  
* Структуры могут содержать **заполнение** (padding) для соблюдения выравнивания; это влияет на `sizeof` и расположение в памяти.  

---

### Знаковость и диапазоны (дополнение до двух)

* Беззнаковый 8-битный: 0…255 (0x00…0xFF). Знаковый 8-битный: −128…127.  
* Переполнение беззнаковых чисел определено как циклическое; **переполнение знаковых чисел - неопределённое поведение** в C.  

---

### Единицы измерения

* 1 **байт** = 8 бит  
* 1 **КиБ** = 1024 байта  
* 1 **МиБ** = 1024 КиБ  
* Для точности используйте КиБ/МиБ/ГиБ; КБ/МБ/ГБ часто используются менее строго.  

---

## Визуальная схема (концептуальное адресное пространство)

```mermaid
%%{init: {'theme':'base', 'themeVariables': { 'primaryColor':'#ffffff','lineColor':'#94a3b8','fontSize':'16px','fontFamily':'Inter, ui-sans-serif','edgeLabelBackground':'#ffffff'}}}%%
flowchart TD
  high[Старшие адреса]
  low[Младшие адреса]
  
  subgraph S[Стек — локальные переменные]
    direction TB
    Sinfo["• Быстрый, автоматический<br/>• Ограниченный размер на поток<br/>• Растёт вниз (↓)"]
  end
  
  subgraph M[Отображённые области — ОС]
    direction TB
    Minfo["• Общие библиотеки<br/>• Файлы, отображённые в память<br/>• Крупные выделения памяти"]
  end
  
  subgraph H[Куча — malloc/free]
    direction TB
    Hinfo["• Гибкий размер<br/>• Управление временем жизни<br/>• Растёт вверх (↑)"]
  end
  
  subgraph G[Статические/Глобальные — вся программа]
    direction TB
    Ginfo["• Существуют всё время работы<br/>• Инициализируются до main()<br/>• Для констант/состояния"]
  end

  high --> S --> M --> H --> G --> low

  classDef addr fill:#f3f4f6,stroke:#6b7280,color:#374151,stroke-dasharray: 5 5,stroke-width:1px;
  classDef stack fill:#fef3c7,stroke:#b45309,color:#111827,stroke-width:1.5px;
  classDef mapped fill:#cffafe,stroke:#0e7490,color:#111827,stroke-width:1.5px;
  classDef heap fill:#dcfce7,stroke:#15803d,color:#111827,stroke-width:1.5px;
  classDef static fill:#fee2e2,stroke:#b91c1c,color:#111827,stroke-width:1.5px;

  class high,low addr;
  class S,Sinfo stack;
  class M,Minfo mapped;
  class H,Hinfo heap;
  class G,Ginfo static;
```

> Это **концептуальная** схема; фактические адреса меняются при каждом запуске из-за ASLR (рандомизации адресного пространства). Относительные роли областей остаются неизменными.

---

## Определения в одном предложении

* **Стек** (Stack) — автоматическое хранилище для каждого вызова функции (локальные переменные, адреса возврата); очень быстрое; ограниченное; освобождается при возврате из функции.  
* **Куча** (Heap) — динамическая память, запрашиваемая через `malloc` и освобождаемая через `free`; гибкий размер; медленнее; вы управляете временем жизни.  
* **Статические/Глобальные** (Static/Globals) — переменные, существующие всё время работы программы (глобальные в области файла или `static` переменные внутри функций).  
* **Отображённые области** (Mapped regions) — области памяти, которые ОС отображает в ваш процесс (общие библиотеки, файлы, отображённые в память, и иногда крупные выделения памяти).  

---

## Пример на C

```c
// globals.c (для иллюстрации)
#include <stdlib.h>

int g = 1;          // глобальная → статическая память (всё время работы)
static int sg = 2;  // static в области файла → статическая память

int main(void) {
    static int sl = 3;      // static в функции → статическая память
    int local = 4;          // стек (существует до возврата из функции)

    int *p = malloc(sizeof *p); // куча (существует до вызова free)
    *p = 5;

    const char *s = "hi";  // указатель в стеке; строка в отображённой, read-only области

    free(p);
    return 0;
}
```

---

## Практические рекомендации

* Предпочитайте **стек** для небольших, кратковременных данных. Это автоматично и быстро.  
* Используйте **кучу** для больших данных или данных переменного размера, которые должны пережить текущую функцию. Всегда освобождайте (`free`) то, что выделили (`malloc`).  
* Используйте **статические/глобальные** для действительно общего, долгоживущего состояния или констант. Не злоупотребляйте ими.  
* **Отображённые области** в основном управляются ОС/средой выполнения (общие библиотеки). При явном вызове `mmap` для файла, работайте с ним как с массивом в памяти.  

---

## Резюме

Этот обзор охватывает фундаментальные концепции организации памяти в программах на C, включая:
- Базовые единицы хранения (биты, байты, слова)
- Адресация памяти и выравнивание
- Знаковые/беззнаковые представления
- Четыре основные области памяти (стек, куча, статические/глобальные, отображённые области)
- Практические рекомендации по использованию памяти

Понимание этих концепций необходимо для написания эффективных, надёжных программ на C и отладки проблем с памятью.