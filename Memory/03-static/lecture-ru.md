# Статическая память — Краткий обзор (C)

**Что это означает**

* **Статическая продолжительность хранения**: объект существует **всё время работы программы**.
* `static` в области файла: символ **скрыт** от других единиц трансляции (внутренняя линковка).
* `static` в области функции: единственный экземпляр, общий для всех вызовов этой функции.
* Объекты со статической продолжительностью хранения по умолчанию **инициализируются нулями** и должны инициализироваться **константой времени компиляции**.

---

## Визуализация: время жизни

```mermaid
graph LR
  START[Начало программы] --> LIVE[Статические/Глобальные существуют всё время]
  LIVE --> END[Завершение программы]
```

---

## Пример 1 · Статическая переменная в функции сохраняет значение

```c
// static_counter.c
#include <stdio.h>

void hit(void) {
    static int count = 0; // инициализируется один раз, сохраняется между вызовами
    ++count;
    printf("hit count = %d
", count);
}

int main(void) {
    hit(); hit(); hit(); // выводит 1, затем 2, затем 3
}
```

**Сборка и запуск**

```bash
gcc -O0 -g -Wall -Wextra static_counter.c -o static_counter
./static_counter
```

---

## Пример 2 · `static` в области файла скрывает символ

```c
// hidden.c
static int hidden = 42;         // внутренняя линковка: не видна вне этого файла
int public_value(void) { return hidden; }
```

```c
// main.c
#include <stdio.h>
int public_value(void);
int main(void) { printf("%d
", public_value()); }
```

**Сборка (два файла)**

```bash
gcc -O0 -g -Wall -Wextra hidden.c main.c -o demo_hidden
./demo_hidden   # выводит 42
```

> Если другой файл попытается использовать `extern int hidden;`, линковщик выдаст ошибку: символ не экспортирован.

---

## Пример 3 · Статические данные для таблиц поиска

```c
// static_table.c
#include <stdio.h>

static const char *keywords[] = { "if", "else", "for", "while", NULL };

int main(void) {
    for (int i = 0; keywords[i]; ++i) puts(keywords[i]);
}
```

* Пометка как `const` делает таблицу доступной только для чтения по типу; `static` делает её приватной для файла и даёт время жизни на всю программу.

---

## Пример 4 · Возврат указателя на статическую переменную (легально, но рискованно)

```c
// static_buf.c
#include <stdio.h>

char *buf(void) {
    static char b[32];     // существует всё время работы программы
    return b;              // легально вернуть этот адрес
}

int main(void) {
    char *p = buf();
    for (int i = 0; i < 5; ++i) p[i] = 'A' + i;
    p[5] = '�';
    puts(p);               // выводит ABCDE
}
```

> **Осторожно**: общее глобальное состояние вредит реентерабельности; несколько вызывающих могут мешать друг другу. Предпочитайте буферы, предоставляемые вызывающей стороной, или динамическое выделение, когда важны параллелизм/повторное использование.

---

## Правила и ограничения (C)

* Инициализация должна быть **константным выражением** (например, числа, адреса глобальных переменных, строковые литералы). Это **неверно** и не скомпилируется:

  ```c
  static int x = getpid(); // ❌ не константное выражение
  ```
* `static` переменные в функциях инициализируются **один раз**, при первом прохождении управления через их объявление.
* Не автоматически потокобезопасны при изменении: защищайте мьютексом или избегайте изменяемых статических переменных.
* `static` ≠ `const`. `static` относится к **времени жизни**/линковке; `const` относится к **изменяемости** через имя.

---

## Когда использовать

* Небольшие таблицы только для чтения или конфигурация, известная во время компиляции.
* Приватное состояние уровня модуля, которое действительно должно существовать всё время работы.
* Избегайте для данных, специфичных для запроса или вызова; передавайте состояние явно или используйте кучу.