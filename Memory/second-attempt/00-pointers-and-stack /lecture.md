# Указатели, стек и байты: понятная визуализация

```
Адрес:   0x2000  0x2001  0x2002  0x2003  0x2004  0x2005  0x2006
Байты:   62      61      64      7A      69      6D      00
```

Ниже — три коротких примера на C, каждый как отдельная мини‑программа. Для каждого примера:
- Сначала код.
- Затем «срезы» памяти с адресами и реальными байтами (little endian), где стек убывает вниз.
- В конце — короткое пояснение простыми словами.

Важно: адреса в таблицах иллюстративные и начинаются с 0x1000, чтобы визуализировать идею «стек растёт вниз». Реальные адреса и расположение переменных зависят от ОС/ABI/компилятора и будут другими на вашей машине.

---

## Этап 1: только char (main + foo(char))

Код демонстрирует аргумент функции и локальную переменную типа `char`.

```c
#include <stdio.h>

void foo(char a) {
    char b = 'B';

    printf("foo: sizeof(char) = %zu\n", sizeof(char));
    printf("foo: a = '%c' (%d), &a = %p\n", a, (int)a, (void*)&a);
    printf("foo: b = '%c' (%d), &b = %p\n", b, (int)b, (void*)&b);
}

int main(void) {
    char c = 'A';

    printf("main: sizeof(char) = %zu\n", sizeof(char));
    printf("main: c = '%c' (%d), &c = %p\n", c, (int)c, (void*)&c);

    foo(c);
    return 0;
}
```

Срез памяти 1 — внутри `main` (до вызова `foo`):

| Адрес   | Значение (байт) | Комментарий           |
|---------|------------------|-----------------------|
| 0x1000  | 0x41             | main: `c = 'A'` (65)  |

Срез памяти 2 — внутри `foo` (новый кадр стека ниже):

| Адрес   | Значение (байт) | Комментарий                           |
|---------|------------------|---------------------------------------|
| 0x1000  | 0x41             | main: `c = 'A'` (выше по стеку)       |
| 0x0FFC  | 0x41             | foo: `a` — копия аргумента `'A'`      |
| 0x0FFB  | 0x42             | foo: `b = 'B'` (66)                   |

Пояснение:
- sizeof: показывает размер типа/объекта в байтах во время компиляции.
- char: занимает 1 байт; `'A'` хранится как 0x41.
- Стек растёт вниз: у нового кадра адреса меньше (0x0FFC < 0x1000).
- Little endian: для многобайтовых чисел младший байт идёт по меньшему адресу (для `char` это не заметно, т.к. 1 байт).

---

## Этап 2: int и char в одной функции

Код показывает размеры и укладку 4‑байтового `int` и 1‑байтового `char`.

```c
#include <stdio.h>

void stage2(void) {
    int x = 10;      // 0x0000000A
    char y = 'A';    // 0x41

    printf("stage2: sizeof(int) = %zu, sizeof(char) = %zu\n",
           sizeof(int), sizeof(char));
    printf("stage2: x = %d, &x = %p\n", x, (void*)&x);
    printf("stage2: y = '%c' (%d), &y = %p\n", y, (int)y, (void*)&y);
}

int main(void) {
    stage2();
    return 0;
}
```

Срез памяти — внутри `stage2` (адреса убывают вниз):

| Адрес   | Значение (байт) | Комментарий                    |
|---------|------------------|--------------------------------|
| 0x1000  | 0x00             | `x` (старший байт, int)        |
| 0x0FFF  | 0x00             | `x`                            |
| 0x0FFE  | 0x00             | `x`                            |
| 0x0FFD  | 0x0A             | `x` (младший байт, int=10)     |
| 0x0FFC  | 0x41             | `y = 'A'` (char)               |

Пояснение:
- sizeof: `sizeof(int)` обычно 4, `sizeof(char)` — всегда 1.
- int: 4 байта. Для 10 в little endian байты: 0x0A 00 00 00 (младший байт по меньшему адресу 0x0FFD).
- char: 1 байт — 0x41.
- Стек растёт вниз: `y` лежит по адресу ниже, чем старшие байты `x`.

---

## Этап 3: long long и double в main

Добавим 8‑байтовые типы: `long long` и `double`. Возьмём значения `1234567890123LL` и `3.14`.

```c
#include <stdio.h>

int main(void) {
    long long big = 1234567890123LL; // 8 байт
    double d = 3.14;                 // 8 байт (IEEE‑754 double)

    printf("main: sizeof(long long) = %zu, sizeof(double) = %zu\n",
           sizeof(long long), sizeof(double));
    printf("main: big = %lld, &big = %p\n", big, (void*)&big);
    printf("main: d = %.17g, &d = %p\n", d, (void*)&d);
    return 0;
}
```

Фактические байты значений (little endian):
- `long long 1234567890123` → байты: `0xCB 0x04 0xFB 0x71 0x1F 0x01 0x00 0x00`
- `double 3.14` → байты: `0x1F 0x85 0xEB 0x51 0xB8 0x1E 0x09 0x40`

Срез памяти — внутри `main` (покажем оба объекта подряд, стек убывает вниз):

| Адрес   | Значение (байт) | Комментарий                                      |
|---------|------------------|--------------------------------------------------|
| 0x1000  | 0x00             | `big` (байт 7 — старший)                         |
| 0x0FFF  | 0x00             | `big` (байт 6)                                   |
| 0x0FFE  | 0x01             | `big` (байт 5)                                   |
| 0x0FFD  | 0x1F             | `big` (байт 4)                                   |
| 0x0FFC  | 0x71             | `big` (байт 3)                                   |
| 0x0FFB  | 0xFB             | `big` (байт 2)                                   |
| 0x0FFA  | 0x04             | `big` (байт 1)                                   |
| 0x0FF9  | 0xCB             | `big` (байт 0 — младший, &big указывает сюда)    |
| 0x0FF8  | 0x40             | `d` (байт 7 — старший)                           |
| 0x0FF7  | 0x09             | `d` (байт 6)                                     |
| 0x0FF6  | 0x1E             | `d` (байт 5)                                     |
| 0x0FF5  | 0xB8             | `d` (байт 4)                                     |
| 0x0FF4  | 0x51             | `d` (байт 3)                                     |
| 0x0FF3  | 0xEB             | `d` (байт 2)                                     |
| 0x0FF2  | 0x85             | `d` (байт 1)                                     |
| 0x0FF1  | 0x1F             | `d` (байт 0 — младший, &d указывает сюда)        |

Пояснение:
- sizeof: на типичных 64‑битных платформах `long long` — 8 байт, `double` — 8 байт.
- Little endian: младший байт числа лежит по меньшему адресу.
- Стек растёт вниз: следующий объект в кадре получает более низкие адреса.
- Адреса в печати `%p` будут другими на вашей машине — это нормально.

---

Итоги и напоминания:
- sizeof: даёт размер типа/объекта в байтах на данной платформе.
- Размеры (часто, но не всегда): `char`=1, `int`=4, `long long`=8, `double`=8.
- Стек растёт вниз: новые кадры/локальные переменные — по меньшим адресам.
- Little endian: порядок байтов внутри числа — от младшего (по меньшему адресу) к старшему (по большему).
