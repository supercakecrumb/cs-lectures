# 1. Контекст и цель

- Разные целочисленные типы в Go помогают точно контролировать диапазоны значений и экономить память, особенно при работе с бинарными протоколами, сетевыми пакетами и низкоуровневой обработкой данных.
- Байт — это 8 последовательных битов. Он стал базовой единицей памяти, потому что архитектуры процессоров и систем хранения сформировались вокруг двоичных схем, удобных для группировки по 8.
- Понимание того, как один байт отображается на типы `uint8` и `int8`, важно для безопасной арифметики, битовых операций и корректного обмена данными между компонентами.

# 2. Типы `uint8` и `int8`: диапазоны и представление

- `uint8` — беззнаковый 8-битный тип. Диапазон: 0…255₁₀ (всего 2⁸ = 256 значений).
- `int8` — знаковый 8-битный тип в дополнительном коде. Диапазон: -128…127₁₀ (тоже 2⁸ = 256 значений).

| Тип    | Минимум       | Максимум      | Ключевые биты |
|--------|---------------|---------------|---------------|
| `uint8`| 00000000₂ = 0₁₀ | 11111111₂ = 255₁₀ | b₇…b₀ — весовые позиции |
| `int8` | 10000000₂ = -128₁₀ | 01111111₂ = 127₁₀ | b₇ — знаковый бит |

- Визуализация байта: `b7 b6 b5 b4 b3 b2 b1 b0`, где b7 — старший (знаковый) бит для `int8`, а b0 — младший бит.

# 3. Краткое напоминание про позиционные системы (только целые)

- Вес разрядов в одном байте: 2⁷, 2⁶, 2⁵, 2⁴, 2³, 2², 2¹, 2⁰.
- Пример: 11010110₂ = 1·2⁷ + 1·2⁶ + 0·2⁵ + 1·2⁴ + 0·2³ + 1·2² + 1·2¹ + 0·2⁰ = 128 + 64 + 16 + 4 + 2 = 214₁₀.

# 4. Дополнительный код (two’s complement) для `int8`

- Two’s complement — способ кодирования отрицательных чисел, в котором арифметика сложения и вычитания одинакова для знаковых и беззнаковых чисел.
- Построение отрицательного значения `-N` (где `0 < N ≤ 128`) из положительного N в 8 битах:
  1. Инвертировать биты (`^0xFF`).
  2. Прибавить 1.
  3. Полученный байт интерпретировать как `int8`.
- Чтобы преобразовать отрицательный байт обратно в десятичное число:
  1. Вычесть 1.
  2. Инвертировать биты.
  3. Поставить минус перед результатом.

### Примеры

- 11111111₂ → -1₁₀
  - Инверсия: 00000000₂
  - +1: 00000001₂ → 1₁₀, значит исходное число было -1₁₀.
- 11111110₂ → -2₁₀
  - Инверсия: 00000001₂
  - +1: 00000010₂ → 2₁₀ ⇒ исходное число -2₁₀.
- 10000000₂ → -128₁₀ (особый случай)
  - Инверсия: 01111111₂
  - +1: 10000000₂ — тот же байт, поэтому обратный шаг даёт 128, но знак остаётся отрицательным, итого -128₁₀.
- 10000001₂ → -127₁₀
  - Инверсия: 01111110₂
  - +1: 01111111₂ → 127₁₀ ⇒ исходное число -127₁₀.

# 5. Одна и та же битовая маска — разные значения

- Один и тот же набор битов можно понимать по-разному в зависимости от типа:
  - 11111111₂ → `uint8 = 255₁₀`, `int8 = -1₁₀`.
  - 10000000₂ → `uint8 = 128₁₀`, `int8 = -128₁₀`.
  - 01111111₂ → `uint8 = 127₁₀`, `int8 = 127₁₀`.
  - 11110110₂ → `uint8 = 246₁₀`, `int8 = -10₁₀` (применяем алгоритм из раздела 4).

# 6. Переполнение (overflow) и «кольцевание»

- Арифметика на 8 битах происходит по модулю 2⁸ = 256. После 255 для `uint8` происходит переход на 0.
- Диапазон `int8` асимметричен: отрицательных значений на одно больше, поэтому `-128₁₀` не имеет положительного аналога в пределах `int8`.
- Пограничные примеры в Go:

```go
var a uint8 = 255
a++ // становится 0

var b int8 = 127
b++ // становится -128

var c int8 = -128
c = -c // остаётся -128 из-за переполнения
```

- «Минус минимума равен самому минимуму», потому что попытка получить противоположное значение требует числа 128, которое не помещается в диапазон `int8`.

# 7. Go-специфика: приведения типов, форматирование, побитовые операции

## Приведения

- `uint8(x)` обрезает значение до младших 8 бит по модулю 256.
- Пример:

```go
package main

import "fmt"

func main() {
    var s int8 = -1
    fmt.Println(uint8(s))   // 255
    fmt.Println(uint16(s))  // 65535
}
```

- Преобразуется числовое значение, а не сами биты: `uint16(s)` даёт 65535₁₀, потому что -1₁₀ расширяется до 0xFFFF₁₆.

## Форматирование вывода

- `%d` — десятичный формат, `%08b` — двоичный с ведущими нулями, `%#x`/`%#X` — шестнадцатеричный с префиксом `0x`/`0X`.

```go
v := uint8(246)
fmt.Printf("%d %08b %#X\n", v, v, v) // 246 11110110 0XF6
```

## Побитовые операции

- Операторы: `&`, `|`, `^`, `&^`, `<<`, `>>`. Для битовых масок удобнее использовать `uint8`, чтобы не учитывать знаковое расширение.

```go
package main

import "fmt"

const (
    Read  = 1 << 2 // 00000100₂
    Write = 1 << 1 // 00000010₂
    Exec  = 1 << 0 // 00000001₂
)

func main() {
    var flags uint8 = 0b10101100
    hasRead := flags&Read != 0
    hasWrite := flags&Write != 0
    hasExec := flags&Exec != 0
    fmt.Printf("flags=%08b read=%t write=%t exec=%t\n", flags, hasRead, hasWrite, hasExec)
}
```

- Для сдвигов `<<`/`>>` важно, чтобы правый операнд был беззнаковым типом (`uint`), иначе компилятор Go выдаст ошибку.

# 8. Отладочная практика: печатай и проверяй

- Когда работаешь с байтами, полезно печатать одно и то же значение в разных представлениях, чтобы вовремя заметить переполнения и неверные приведения.

```go
package main

import "fmt"

func dumpByte(u uint8) {
    i := int8(u)
    fmt.Printf("bits=%08b  uint8=%3d  int8=%4d  hex=%#02X\n", u, u, i, u)
}

func main() {
    for _, v := range []uint8{0, 1, 127, 128, 246, 255} {
        dumpByte(v)
    }
}
```

- Такой хелпер помогает визуально сопоставлять значение в системах счисления, а также видеть интерпретацию как `uint8` и `int8` одновременно.

# 9. Мини-задачник 

1. Представьте байт 0b01001110 как `uint8` и `int8`, выпишите значения в десятичной и шестнадцатеричной системах.
2. Найдите `int8`-значение для двоичного числа 11100101₂ и поясните шаги преобразования.
3. Что произойдёт в Go при выполнении `var x uint8 = 200; var y int8 = int8(x)`? Запишите оба значения в десятичной форме.
4. Покажите результат `uint8(300)` и объясните, почему он получается именно таким.
5. Напишите выражение Go, которое устанавливает и снимает биты 5 и 2 в байте `0b00101101`, и укажите итоговое значение.
